from django.conf import settings
from math import ceil
from math import sqrt
from random import randrange
from random import uniform
from random import choice
from random import shuffle
from string import lowercase


class Utility(object):

    #########################################################
    ###  Utility functions for game generator function    ###
    #########################################################

    def get_word_length(self, *args, **kwargs):
        '''Depending on the level of the user this function returns the length of the word that
            the Robot will create for the user

        Keyword arguments:
        level -- the user's game level

        Returns: number

        '''

        level = kwargs.get('level', 1)

        if level < 1:
            return -1

        # Finding a number which will be inversely dependent upon
        # the level and is between 2 and WORD_MAX_LENGTH
        number = int(ceil((settings.WORD_MAX_LENGTH - 1) / ceil(sqrt(level)) + 1))

        # We find some random offset for our calculation
        offset = randrange(0, settings.LENGTH_OFFSET_NUMBER)

        if offset == 0:
            # If the offset is 0 then we take the number as the word length
            word_length = number
        else:
            # We choose a number between (number - offser, number + offset)
            lower_bound = max(settings.WORD_MIN_LENGTH, number - offset)
            upper_bound = min(settings.WORD_MAX_LENGTH, number + offset)
            word_length = randrange(lower_bound, upper_bound)

        return word_length

    def get_word_by_length(self, *args, **kwargs):
        '''Generates a sequence of letters as a new word.
            This is a temporary function to close the loop.
            Will need to replace this with an actual word generator.

        Keyword arguments:
        length -- the length of the generating word

        Returns: string

        '''

        length = kwargs.get('length', 5)
        word = ''.join(choice(lowercase) for i in range(length))

        return word

    def generate_letter_list(self, *args, **kwargs):
        '''Generates a list of letters, which contains all the letters from the actual word
            and adds more letters

        Keyword arguments:
        existing_letters -- the list of existing letters in the word generated by the robot

        Returns: list
        '''

        letters = kwargs.get('existing_letters', [])

        if settings.MAX_LETTER_COUNT > len(letters):
            existing_vowels = self.get_vowels(letters=letters)
            existing_consonants = self.get_consonants(letters=letters)

            vowel_distribution = uniform(0.1, 0.4)
            vowel_distribution += len(existing_vowels) / float(settings.MAX_LETTER_COUNT)

            missing_vowels_count = int(round(settings.MAX_LETTER_COUNT * vowel_distribution) - len(existing_vowels))
            missing_consonant_count = int(settings.MAX_LETTER_COUNT - missing_vowels_count - len(existing_vowels) - len(existing_consonants))

            for index in range(missing_vowels_count):
                letters.append(settings.LIST_OF_VOWELS[randrange(len(settings.LIST_OF_VOWELS))])

            for index in range(missing_consonant_count):
                letters.append(settings.LIST_OF_CONSONANTS[randrange(len(settings.LIST_OF_CONSONANTS))])

            shuffle(letters)

        return letters

    def get_vowels(self, *args, **kwargs):
        '''Finds and returns all the vowels from the list of provided letters

        Keyword arguments:
        letters -- the list of letters

        Returns: list
        '''

        letters = kwargs.get('letters', '')
        vowels = [letter for letter in letters if letter in settings.LIST_OF_VOWELS]

        return vowels

    def get_consonants(self, *args, **kwargs):
        '''Finds and returns all the consonants from the list of provided letters

        Keyword arguments:
        letters -- the list of letters

        Returns: list
        '''

        letters = kwargs.get('letters', '')
        consonants = [letter for letter in letters if letter in settings.LIST_OF_CONSONANTS]

        return consonants

    #########################################################
    ###  Utility functions for game guessting function    ###
    #########################################################

    def get_attempts_number(self, *args, **kwargs):
        '''Using a mathematical formula generates a number of the attempts
            that should be hypothetically made by the Robot

        Keyword arguments:
        level -- the level of the user

        Returns: number
        '''

        level = kwargs.get('level', 1)

        # Finding a number which will be inversely dependent upon
        # the level and is between 2 and WORD_MAX_ATTEMPT
        number = int(ceil((settings.WORD_MAX_ATTEMPT - 1) / ceil(sqrt(level)) + 1))

        # We find some random offset for our calculation
        offset = randrange(0, settings.ATTEMPT_OFFSET_NUMBER)

        if offset == 0:
            # If the offset is 0 then we take the number as the word length
            attempts_count = number
        else:
            # We choose a number between (number - offser, number + offset)
            lower_bound = max(0, number - offset)
            upper_bound = min(settings.WORD_MAX_ATTEMPT, number + offset)
            attempts_count = randrange(lower_bound, upper_bound)

        return attempts_count

    def generate_word(self, *args, **kwargs):
        '''Generates a new word having external information, such as the list of the letters,
            the length of the guessing word, and the history and results of previous attempt

        Keyword arguments:
        letters -- the list of letters to choose from
        word_length -- the length of the guessing word
        word_result -- the result of the previous attempt

        Returns: string
        '''

        letters = kwargs.get('letters', [])
        word_length = kwargs.get('word_length', 0)
        word_result = kwargs.get('word_result', None)

        if word_result is None:
            shuffle(letters)
            new_word = letters[0:word_length]

        else:
            DEFAULT_CHARACTER = 0
            new_word = [DEFAULT_CHARACTER] * word_length
            floating_letters = []
            fixed_letters = []
            remaining_letters = letters[:]

            for index, letter_info in enumerate(word_result):
                if letter_info['letter'] in remaining_letters:
                    remaining_letters.remove(letter_info['letter'])

                # The correct word contains this letter, but the position is wrong
                if letter_info['result'] == 2:
                    floating_letters.append(letter_info['letter'])

                # The correct word doesn't contain this letter
                elif letter_info['result'] == 0:
                    letters.remove(letter_info['letter'])

                # The letter is correct, we keep this
                elif letter_info['result'] == 1:
                    fixed_letters.append(letter_info['letter'])
                    new_word[index] = letter_info['letter']

            incorrect_letter_indexes = [i for i, letter in enumerate(new_word) if letter == DEFAULT_CHARACTER]
            for letter in floating_letters:
                random_index = choice(incorrect_letter_indexes)
                new_word[random_index] = letter

                incorrect_letter_indexes.remove(random_index)

            for index in incorrect_letter_indexes:
                new_word[index] = choice(remaining_letters)
                remaining_letters.remove(new_word[index])

        return ''.join(new_word)

    def compare_words(self, *args, **kwargs):
        '''Compares the guessed and correct words and returns a dictionary.
            If the guessed word matches the correct word then "is_correct" attribute will be True and "word_result"
            will be null. Otherwise "is_correct" will be False and "word_result" will contains a list of dictionaries.
            Each dictionary has information for every single letter in the guessed word - the actual letter and whether
            it was correct (1), wrong (0), or the word contains that letter but the position was wrong (2).

        Keyword arguments:
        guessed_word -- the word that the Robot has guessed
        correct_word -- the correct word picked by the user

        Returns: dictionary
        '''

        guessed_word = kwargs.get('guessed_word', '')
        correct_word = kwargs.get('correct_word', '')

        if correct_word == guessed_word:
            result = {'is_correct': True, 'word_result': {}}

        else:
            guessed_letters = list(guessed_word)
            correct_letters = list(correct_word)
            result = {'is_correct': False, 'word_result': [{'letter': letter, 'result': 0} for letter in list(guessed_word)]}

            index = 0
            correct_letters_cpy = correct_letters[:]
            for guessed_letter, correct_letter in zip(guessed_letters, correct_letters):
                if guessed_letter == correct_letter:
                    result['word_result'][index]['result'] = 1
                    correct_letters_cpy.remove(guessed_letter)

                index += 1

            index = 0
            for guessed_letter, correct_letter in zip(guessed_letters, correct_letters):
                if guessed_letter != correct_letter:
                    if guessed_letter in correct_letters_cpy:
                        correct_letters_cpy.remove(guessed_letter)
                        result['word_result'][index]['result'] = 2

                    else:
                        result['word_result'][index]['result'] = 0

                index += 1

        return result
